import { randomBytes } from 'crypto'

type InputType = {
  id?: string;
  tests?: any[];
}

export const createMissedId = <T extends InputType>(data: T): T & { id: string } => {
  /*
    Если длина 28, значит, мы сами сгенерили этот айдишник. Если длина 22 - значит, его сгенерил CodeceptJS.
    28 символов - это base64 из 20 случайных байтов.

    Почему мы не берем кодцептовый id? Дело в том, что кодцептовый айдишник - это хеш на основе suiteName + testName.
    Если брать его, то у нас не попадут в статистику тесты с одинаковыми названиями suite и scenario.
    Длина хеша 22 у CodeceptJS по причине их секьюронсти - они слайсят последние 2 символа (for no reason).

    При попытке создать свое поле (uniqId / uuid / etc.) CodeceptJS съедает это поле и оно не записывается в объект,
    в отличие от поля id, которое, по всей видимости, кастомный mocha runner прокидывает во все хуки.

    Зачем нам вообще уникальные id и id в принципе?
     1. Для того чтобы учитывать тесты с одинаковыми suite / scenario
     2. Для того чтобы учесть, какие тесты "скипнуты" при падении в Suite. Хук .failed не возвращает статус тестов, которые
      были скипнуты, если упал Suite. По айдишникам мы можем определить, что произошло и какие тесты нам нужны.

    data.tests мы прогоняем отдельно, поскольку тесты инициализируются (вы не поверите) в хуке beforeSuite.
    Если их там не проинициализировать, то мы не сможем записать, какие тесты скипнуты (проблема п.2 из предыдущего абзаца)
   */
  if (data.tests) {
    data.tests = data.tests.map(createMissedId)
  }

  if (data.id && data.id.length === 28) {
    return data as T & { id: string }
  }

  data.id = randomBytes(20).toString('base64')

  return data as T & { id: string }
}
